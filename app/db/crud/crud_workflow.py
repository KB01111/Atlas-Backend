"""CRUD operations for Workflows.

Handles database interactions for storing, retrieving, updating, and deleting
workflows, ensuring user ownership and RLS.
"""

import logging
from typing import Optional

from postgrest import APIError  # type: ignore

# Assuming supabase_py_async client is used, adjust imports if using Prisma
from supabase_py_async import AsyncClient

from app.models.workflow import (
    WorkflowCreate,
    WorkflowOut,
    WorkflowUpdate,
)

logger = logging.getLogger(__name__)

TABLE_NAME = "workflows"


async def create_workflow(
    db: AsyncClient,
    *,  # Enforce keyword arguments
    user_id: str,
    workflow_in: WorkflowCreate,
) -> WorkflowOut:
    """Create a new workflow record for a user."""
    # Pydantic v2 automatically handles JSON serialization for complex types like List[WorkflowStep]
    insert_data = workflow_in.model_dump(mode="json")  # Ensure steps list is JSON serializable
    insert_data["user_id"] = user_id
    # Assuming 'id' is generated by default or using uuid4 if needed
    # insert_data["id"] = str(uuid4())

    try:
        result = (
            await db.table(TABLE_NAME)
            .insert(insert_data)
            .execute()
        )
        if not result.data:
            logger.error(
                f"Failed to create workflow for "
                f"user {user_id}. "
                f"No data returned."
            )
            raise ValueError("Workflow creation failed.")

        created_workflow_dict = result.data[0]
        logger.info(
            f"Created workflow {created_workflow_dict['id']} "
            f"for user {user_id}"
        )
        # Pydantic v2 automatically handles JSON deserialization for complex types
        return WorkflowOut.model_validate(created_workflow_dict)
    except APIError as e:
        logger.error(
            f"Supabase API Error creating workflow for user {user_id}: {e}"
        )
        raise
    except Exception as e:
        logger.error(
            f"Unexpected error creating workflow for user {user_id}: {e}"
        )
        raise ValueError(f"Workflow creation failed: {e}") from e


async def get_workflow(
    db: AsyncClient, *, user_id: str, workflow_id: str
) -> Optional[WorkflowOut]:
    """Retrieve a specific workflow by ID for a user."""
    try:
        result = (
            await db.table(TABLE_NAME)
            .select("*")
            .eq("id", workflow_id)
            .eq("user_id", user_id)  # Ensure user ownership (RLS)
            .maybe_single()
            .execute()
        )
        if not result.data:
            logger.warning(
                f"Workflow {workflow_id} not found for user {user_id}"
            )
            return None

        logger.debug(
            f"Retrieved workflow {workflow_id} for user {user_id}"
        )
        return WorkflowOut.model_validate(result.data)
    except APIError as e:
        logger.error(
            f"Supabase API Error retrieving workflow {workflow_id} "
            f"for user {user_id}: {e}"
        )
        raise
    except Exception as e:
        logger.error(
            f"Unexpected error retrieving workflow {workflow_id} "
            f"for user {user_id}: {e}"
        )
        raise


async def get_workflows_by_user(
    db: AsyncClient, *, user_id: str
) -> list[WorkflowOut]:
    """Retrieve all workflows for a specific user."""
    try:
        result = (
            await db.table(TABLE_NAME)
            .select("*")
            .eq("user_id", user_id)
            .execute()
        )
        logger.debug(
            f"Retrieved {len(result.data)} workflows for user {user_id}"
        )
        return [
            WorkflowOut.model_validate(item) for item in result.data
        ]
    except APIError as e:
        logger.error(
            f"Supabase API Error retrieving workflows for user {user_id}: {e}"
        )
        raise
    except Exception as e:
        logger.error(
            f"Unexpected error retrieving workflows for user {user_id}: {e}"
        )
        raise


async def update_workflow(
    db: AsyncClient,
    *,
    user_id: str,
    workflow_id: str,
    workflow_in: WorkflowUpdate,
) -> Optional[WorkflowOut]:
    """Update an existing workflow for a user."""
    # Use mode='json' to serialize 'steps' if it's being updated
    update_data = workflow_in.model_dump(exclude_unset=True, mode="json")

    if not update_data:
        logger.warning("Workflow update called with no data.")
        # Optionally return the existing object if no changes needed
        return await get_workflow(
            db, user_id=user_id, workflow_id=workflow_id
        )

    try:
        result = (
            await db.table(TABLE_NAME)
            .update(update_data)
            .eq("id", workflow_id)
            .eq("user_id", user_id)  # Ensure user ownership (RLS)
            .execute()
        )
        if not result.data:
            logger.warning(
                f"Workflow {workflow_id} not found for update by user {user_id}"
            )
            return None

        updated_workflow_dict = result.data[0]
        logger.info(
            f"Updated workflow {workflow_id} for user {user_id}"
        )
        return WorkflowOut.model_validate(updated_workflow_dict)
    except APIError as e:
        logger.error(
            f"Supabase API Error updating workflow {workflow_id} "
            f"for user {user_id}: {e}"
        )
        raise
    except Exception as e:
        logger.error(
            f"Unexpected error updating workflow {workflow_id} "
            f"for user {user_id}: {e}"
        )
        raise


async def delete_workflow(
    db: AsyncClient, *, user_id: str, workflow_id: str
) -> bool:
    """Delete a workflow for a user. Returns True if deleted, False otherwise."""
    try:
        result = (
            await db.table(TABLE_NAME)
            .delete()
            .eq("id", workflow_id)
            .eq("user_id", user_id)  # Ensure user ownership (RLS)
            .execute()
        )
        # Check if any row was actually deleted
        deleted = bool(result.data)
        if deleted:
            logger.info(
                f"Deleted workflow {workflow_id} for user {user_id}"
            )
        else:
            logger.warning(
                f"Workflow {workflow_id} not found for deletion by user {user_id}"
            )
        return deleted
    except APIError as e:
        logger.error(
            f"Supabase API Error deleting workflow {workflow_id} "
            f"for user {user_id}: {e}"
        )
        raise
    except Exception as e:
        logger.error(
            f"Unexpected error deleting workflow {workflow_id} "
            f"for user {user_id}: {e}"
        )
        raise
